!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports):"function"==typeof define&&define.amd?define(["exports"],t):t((e=e||self).app={})}(this,(function(e){"use strict";function t(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function n(e){return e=e||Object.create(null),{on:function(t,n){(e[t]||(e[t]=[])).push(n)},off:function(t,n){e[t]&&e[t].splice(e[t].indexOf(n)>>>0,1)},emit:function(t,n){(e[t]||[]).slice().map((function(e){e(n)})),(e["*"]||[]).slice().map((function(e){e(t,n)}))}}}function s(e){const t={url:"/graphql",method:"POST",headers:{Accept:"application/json"}};return t.headers["Content-Type"]="application/json",t.body=JSON.stringify(e),t}function o(e){for(var t=o.BASE,n=0,s=e.length;n<s;n++)t^=e.charCodeAt(n),t+=(t<<1)+(t<<4)+(t<<7)+(t<<8)+(t<<24);return t>>>0}o.BASE=2166136261;var r=o;function i(e,t){const n=this[e];if("undefined"!=typeof FormData&&n instanceof FormData){let e="";const t=n.entries();let s=t.next();for(;!s.done;){const[n,o]=s.value;e+="".concat(n).concat(o),s=t.next()}return e}return t}const c=e=>r(JSON.stringify(e,i)).toString(36);class a{constructor({cache:e={}}={}){t(this,"reload",e=>{this.emit("reload",{exceptCacheKey:e})}),t(this,"reset",e=>{let t=Object.keys(this.cache);e&&(t=t.filter(t=>t!==e)),t.forEach(e=>delete this.cache[e]),this.emit("reset",{exceptCacheKey:e})}),t(this,"fetch",({url:e,...t},n)=>{let s;const o="function"==typeof fetch?fetch:()=>Promise.reject(new Error("Global fetch API or polyfill unavailable.")),r={},i=o(e,t).then(e=>(s=e,e.ok||(r.httpError={status:e.status,statusText:e.statusText}),e.json().then(({errors:e,data:t})=>{e||t||(r.parseError="Malformed payload."),e&&(r.graphQLErrors=e),t&&(r.data=t)},({message:e})=>{r.parseError=e})),({message:e})=>{r.fetchError=e}).then(()=>(r.graphQLErrors||r.parseError||(this.cache[n]=r),this.operations[n].length||delete this.operations[n],this.emit("cache",{cacheKey:n,cacheValue:r,response:s}),r));return this.operations[n]=i,this.emit("fetch",{cacheKey:n,cacheValuePromise:i}),i}),t(this,"operate",({operation:e,fetchOptionsOverride:t,reloadOnLoad:n,resetOnLoad:o})=>{if(n&&o)throw new Error("operate() options “reloadOnLoad” and “resetOnLoad” can’t both be true.");const r=s(e);t&&t(r);const i=c(r),a=this.operations[i]||this.fetch(r,i);return a.then(()=>{n?this.reload(i):o&&this.reset(i)}),{cacheKey:i,cacheValue:this.cache[i],cacheValuePromise:a}});const{on:o,off:r,emit:i}=n();this.on=o,this.off=r,this.emit=i,this.cache=e,this.operations={}}}function h(){return(h=Object.assign||function(e){for(var t=1;t<arguments.length;t++){var n=arguments[t];for(var s in n)Object.prototype.hasOwnProperty.call(n,s)&&(e[s]=n[s])}return e}).apply(this,arguments)}var l=u;function u(e){e=e||{},this.ms=e.min||100,this.max=e.max||1e4,this.factor=e.factor||2,this.jitter=e.jitter>0&&e.jitter<=1?e.jitter:0,this.attempts=0}u.prototype.duration=function(){var e=this.ms*Math.pow(this.factor,this.attempts++);if(this.jitter){var t=Math.random(),n=Math.floor(t*this.jitter*e);e=0==(1&Math.floor(10*t))?e-n:e+n}return 0|Math.min(e,this.max)},u.prototype.reset=function(){this.attempts=0};var p=function(e){var t,n=e.Symbol;if("function"==typeof n)if(n.observable)t=n.observable;else{t=n.for("https://github.com/benlesh/symbol-observable");try{n.observable=t}catch(e){}}else t="@@observable";return t}("undefined"!=typeof self?self:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof module?module:Function("return this")());const d=3e4;function m(e){return"string"==typeof e}class f{constructor(e,t){const{connectionCallback:s,connectionParams:o={},timeout:r=d,reconnect:i=!1,reconnectionAttempts:c=1/0,lazy:a=!1,inactivityTimeout:h=0}=t||{};this.wsImpl=WebSocket,this.connectionCallback=s,this.url=e,this.operations={},this.nextOperationId=0,this.wsTimeout=r,this.unsentMessagesQueue=[],this.reconnect=i,this.reconnecting=!1,this.reconnectionAttempts=c,this.lazy=!!a,this.inactivityTimeout=h,this.closedByUser=!1,this.backoff=new l({jitter:.5}),this.eventEmitter=n(),this.client=null,this.maxConnectTimeGenerator=this.createMaxConnectTimeGenerator(),this.connectionParams=this.getConnectionParams(o),this.lazy||this.connect()}get status(){return null===this.client?this.wsImpl.CLOSED:this.client.readyState}close(e=!0,t=!0){this.clearInactivityTimeout(),null!==this.client&&(this.closedByUser=t,e&&(this.clearCheckConnectionInterval(),this.clearMaxConnectTimeout(),this.clearTryReconnectTimeout(),this.unsubscribeAll(),this.sendMessage(void 0,"connection_terminate",null)),this.client.close(),this.client=null,this.eventEmitter.emit("disconnected"),e||this.tryReconnect())}request(e){const t=this.getObserver.bind(this),n=this.executeOperation.bind(this),s=this.unsubscribe.bind(this);let o;return this.clearInactivityTimeout(),{[p.default?p.default:p](){return this},subscribe(r,i,c){const a=t(r,i,c);return o=n(e,(e,t)=>{null===e&&null===t?a.complete&&a.complete():e?a.error&&a.error(e[0]):a.next&&a.next(t)}),{unsubscribe:()=>{o&&(s(o),o=null)}}}}}on(e,t,n){const s=this.eventEmitter.on(e,t,n);return()=>{s.off(e,t,n)}}onConnected(e,t){return this.on("connected",e,t)}onConnecting(e,t){return this.on("connecting",e,t)}onDisconnected(e,t){return this.on("disconnected",e,t)}onReconnected(e,t){return this.on("reconnected",e,t)}onReconnecting(e,t){return this.on("reconnecting",e,t)}onError(e,t){return this.on("error",e,t)}unsubscribeAll(){Object.keys(this.operations).forEach(e=>{this.unsubscribe(e)})}getConnectionParams(e){return()=>new Promise((t,n)=>{if("function"==typeof e)try{return t(e(null))}catch(e){return n(e)}t(e)})}executeOperation(e,t){null===this.client&&this.connect();const n=this.generateOperationId();this.operations[n]={options:e,handler:t};try{this.checkOperationOptions(e,t),this.operations[n]&&(this.operations[n]={options:e,handler:t},this.sendMessage(n,"start",e))}catch(e){this.unsubscribe(n),t(this.formatErrors(e))}return n}getObserver(e,t,n){return"function"==typeof e?{next:t=>e(t),error:e=>t&&t(e),complete:()=>n&&n()}:e}createMaxConnectTimeGenerator(){const e=this.wsTimeout;return new l({min:1e3,max:e,factor:1.2})}clearCheckConnectionInterval(){this.checkConnectionIntervalId&&(clearInterval(this.checkConnectionIntervalId),this.checkConnectionIntervalId=null)}clearMaxConnectTimeout(){this.maxConnectTimeoutId&&(clearTimeout(this.maxConnectTimeoutId),this.maxConnectTimeoutId=null)}clearTryReconnectTimeout(){this.tryReconnectTimeoutId&&(clearTimeout(this.tryReconnectTimeoutId),this.tryReconnectTimeoutId=null)}clearInactivityTimeout(){this.inactivityTimeoutId&&(clearTimeout(this.inactivityTimeoutId),this.inactivityTimeoutId=null)}setInactivityTimeout(){this.inactivityTimeout>0&&0===Object.keys(this.operations).length&&(this.inactivityTimeoutId=setTimeout(()=>{0===Object.keys(this.operations).length&&this.close()},this.inactivityTimeout))}checkOperationOptions(e,t){const{query:n,variables:s,operationName:o}=e;if(!n)throw new Error("Must provide a query.");if(!t)throw new Error("Must provide an handler.");if(!m(n)||o&&!m(o)||s&&(null===(r=s)||"object"!=typeof r))throw new Error("Incorrect option types. query must be a string,`operationName` must be a string, and `variables` must be an object.");var r}buildMessage(e,t,n){return{id:e,type:t,payload:n&&n.query?h({},n,{query:n.query}):n}}formatErrors(e){return Array.isArray(e)?e:e&&e.errors?this.formatErrors(e.errors):e&&e.message?[e]:[{name:"FormatedError",message:"Unknown error",originalError:e}]}sendMessage(e,t,n){this.sendMessageRaw(this.buildMessage(e,t,n))}sendMessageRaw(e){switch(this.status){case this.wsImpl.OPEN:const t=JSON.stringify(e);try{JSON.parse(t)}catch(t){this.eventEmitter.emit("error",new Error("Message must be JSON-serializable. Got: ".concat(e)))}this.client.send(t);break;case this.wsImpl.CONNECTING:this.unsentMessagesQueue.push(e);break;default:this.reconnecting||this.eventEmitter.emit("error",new Error("A message was not sent because socket is not connected, is closing or is already closed. Message was: "+JSON.stringify(e)))}}generateOperationId(){return String(++this.nextOperationId)}tryReconnect(){if(!this.reconnect||this.backoff.attempts>=this.reconnectionAttempts)return;this.reconnecting||(Object.keys(this.operations).forEach(e=>{this.unsentMessagesQueue.push(this.buildMessage(e,"start",this.operations[e].options))}),this.reconnecting=!0),this.clearTryReconnectTimeout();const e=this.backoff.duration();this.tryReconnectTimeoutId=setTimeout(()=>{this.connect()},e)}flushUnsentMessagesQueue(){this.unsentMessagesQueue.forEach(e=>{this.sendMessageRaw(e)}),this.unsentMessagesQueue=[]}checkConnection(){this.wasKeepAliveReceived?this.wasKeepAliveReceived=!1:this.reconnecting||this.close(!1,!0)}checkMaxConnectTimeout(){this.clearMaxConnectTimeout(),this.maxConnectTimeoutId=setTimeout(()=>{this.status!==this.wsImpl.OPEN&&(this.reconnecting=!0,this.close(!1,!0))},this.maxConnectTimeGenerator.duration())}connect(){this.client=new WebSocket(this.url,"graphql-ws"),this.checkMaxConnectTimeout(),this.client.addEventListener("open",async()=>{if(this.status===this.wsImpl.OPEN){this.clearMaxConnectTimeout(),this.closedByUser=!1,this.eventEmitter.emit(this.reconnecting?"reconnecting":"connecting");try{const e=await this.connectionParams();this.sendMessage(void 0,"connection_init",e),this.flushUnsentMessagesQueue()}catch(e){this.sendMessage(void 0,"connection_error",e),this.flushUnsentMessagesQueue()}}}),this.client.onclose=()=>{this.closedByUser||this.close(!1,!1)},this.client.addEventListener("error",e=>{this.eventEmitter.emit("error",e)}),this.client.addEventListener("message",({data:e})=>{this.processReceivedData(e)})}processReceivedData(e){let t,n;try{t=JSON.parse(e),n=t.id}catch(t){throw new Error("Message must be JSON-parseable. Got: ".concat(e))}if(!["data","complete","error"].includes(t.type)||this.operations[n])switch(t.type){case"connection_error":this.connectionCallback&&this.connectionCallback(t.payload);break;case"connection_ack":this.eventEmitter.emit(this.reconnecting?"reconnected":"connected"),this.reconnecting=!1,this.backoff.reset(),this.maxConnectTimeGenerator.reset(),this.connectionCallback&&this.connectionCallback();break;case"complete":this.operations[n].handler(null,null),delete this.operations[n];break;case"error":this.operations[n].handler(this.formatErrors(t.payload),null),delete this.operations[n];break;case"data":const e=t.payload.errors?{...t.payload,errors:this.formatErrors(t.payload.errors)}:t.payload;this.operations[n].handler(null,e);break;case"ka":const s=void 0===this.wasKeepAliveReceived;this.wasKeepAliveReceived=!0,s&&this.checkConnection(),this.checkConnectionIntervalId&&(clearInterval(this.checkConnectionIntervalId),this.checkConnection()),this.checkConnectionIntervalId=setInterval(this.checkConnection.bind(this),this.wsTimeout);break;default:throw new Error("Invalid message type!")}else this.unsubscribe(n)}unsubscribe(e){this.operations[e]&&(delete this.operations[e],this.setInactivityTimeout(),this.sendMessage(e,"stop",void 0))}}function b(e,t){return new f(e,t)}function y(){}const g=[];const v=new a;function E(e,t){const{subscribe:n,set:s}=function(e,t=y){let n;const s=[];function o(t){if(r=t,((o=e)!=o?r==r:o!==r||o&&"object"==typeof o||"function"==typeof o)&&(e=t,n)){const t=!g.length;for(let t=0;t<s.length;t+=1){const n=s[t];n[1](),g.push(n,e)}if(t){for(let e=0;e<g.length;e+=2)g[e][0](g[e+1]);g.length=0}}var o,r}return{set:o,update:function(t){o(t(e))},subscribe:function(r,i=y){const c=[r,i];return s.push(c),1===s.length&&(n=t(o)||y),r(e),()=>{const e=s.indexOf(c);-1!==e&&s.splice(e,1),0===s.length&&(n(),n=null)}}}}(e);return{subscribe:n,set:(e=(e=>e))=>{s(v.cache[t]=e(v.cache[t]))}}}function w(e,t,n=!0,o=(e=>e)){const r=s({...t});e(r);const i=c(r);if(o(i),v.cache[i]&&v.cache[i].graphQLErrors&&delete v.cache[i],v.cache[i]&&n)return new Promise(e=>e(v.cache[i]));return v.operate({fetchOptionsOverride:e,operation:{...t}}).cacheValuePromise}let T=(e,t,n=!0)=>w(e,t,n);e.GraphQL=a,e.GraphQLSvelte=e=>{let t={};if(e.headers||(e.headers={"content-type":"application/json"}),e.ws){let s=(n=e.ws,o=e.headers,new b(n.url,{reconnect:n.reconnect||!0,lazy:n.lazy||!0,...n.connectionParams?{connectionParams:n.connectionParams}:{connectionParams:()=>({headers:{...o()}})}}));t.subscription=s,t.subscribe=e=>((e,t)=>e.request(t))(s,e)}var n,o;if(!e.url)throw new Error("graphql endpoint not set");const r=t=>{t.url=e.url,t.headers=e.headers()};return t.get=(e,t)=>T(r,e,t),t.restore=(e,t)=>function(e,t,n){if(t){const o=s({...t});e(o);const r=c(o);return v.cache[r]&&(v.cache[r]=n),v.cache[r]}}(r,e,t),t.query=(e,t)=>((e,t,n=!0)=>{let s,o="";const r=new Promise(e=>s=e);w(e,t,n,e=>o=e).then(e=>{i.set(()=>v.cache[o]),s(Promise.resolve(v.cache[o]))});const i=E(r,o);return i})(r,e,t),t.mutate=(e,t=!1)=>T(r,e,t),t=h(t,v),{...t}},e.SubscribeQL=b,e.graphqlFetchOptions=s,e.hashObject=c,e.reportCacheErrors=function({cacheKey:e,cacheValue:{fetchError:t,httpError:n,parseError:s,graphQLErrors:o}}){(t||n||s||o)&&(console.groupCollapsed("GraphQL cache errors for key “".concat(e,"”:")),t&&(console.groupCollapsed("Fetch:"),console.log(t),console.groupEnd()),n&&(console.groupCollapsed("HTTP:"),console.log("Status: ".concat(n.status)),console.log("Text: ".concat(n.statusText)),console.groupEnd()),s&&(console.groupCollapsed("Parse:"),console.log(s),console.groupEnd()),o&&(console.groupCollapsed("GraphQL:"),o.forEach(({message:e})=>console.log(e)),console.groupEnd()),console.groupEnd())},Object.defineProperty(e,"__esModule",{value:!0})}));
//# sourceMappingURL=graphql-svelte.js.map
